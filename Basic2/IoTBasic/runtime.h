/*
 * Stefan's basic interpreter. 
 *
 * Prototypes for the runtime environment of the BASIC interpreter.
 *
 * Needs to be included by runtime.c or runtime.cpp and basic.c as 
 * it describes the interface between the BASIC interpreter and the
 * runtime environment.
 * 
 * Most configurable parameters are in hardware.h.
 *
 * Author: Stefan Lenz, sl001@serverfabrik.de
 * 
 */

#if !defined(__RUNTIMEH__)
#define __RUNTIMEH__ 

/* 
 * The system type identifiers
 * 
 * SYSTYPE_UNKNOWN: unknown system, typically an unknown Arduino
 * SYSTYPE_AVR: an AVR based Arduino, like the UNO, NANO, MEGA, PRO
 * SYSTYPE_ESP8266: an ESP8266 based Arduino, like the Wemos D1, very common and generic
 * SYSTYPE_ESP32: an ESP32 based Arduino, like the Wemos Lolin32, very common and generic
 * SYSTYPE_RP2040: a Raspberry PI Pico, the first RP2040 based Arduino
 * SYSTYPE_SAM: a SAM based Arduino, like the DUE
 * SYSTYPE_XMC: an XMC based Arduino, like the Infineon XMC1100
 * SYSTYPE_SMT32: an STM32 based Arduino, like the Blue Pill
 * SYSTYPE_NRENESA: a Renesas based Arduino, like the R4 Wifi and Minimal
 * SYSTYPE_GIGA: Arduino GIGA board 
 * SYSTYPE_POSIX: a POSIX system, like Linux, MacOS
 * SYSTYPE_MSDOS: a DOS system, like FreeDOS
 * SYSTYPE_MINGW: a Windows system with MinGW
 * SYSTYPE_RASPPI: a Raspberry PI system
 * 
 * Number ranges from 0-31 are reserved for Arduino systems
 * Number ranges from 32-63 are reserved for POSIX systems
 */

#define SYSTYPE_UNKNOWN	0
#define SYSTYPE_AVR 	1
#define SYSTYPE_ESP8266 2
#define SYSTYPE_ESP32	3
#define SYSTYPE_RP2040  4
#define SYSTYPE_SAM     5
#define SYSTYPE_XMC		6
#define SYSTYPE_SMT32	7
#define SYSTYPE_NRENESA 8
#define SYSTYPE_GIGA    9
#define SYSTYPE_POSIX	32
#define SYSTYPE_MSDOS	33
#define SYSTYPE_MINGW   34
#define SYSTYPE_RASPPI  35

/* 
 * Input and output channels.
 * 
 * The channels are used to identify the I/O devices in the
 * runtime environment. 
 * 
 * NULL is the memory channel outputting to a buffer.
 * SERIAL is the standard serial channel and the default device. 
 * DSP is the display channel.
 * GRAPH is the additional graphics display channel.
 * PRT is the second serial channel used for printing and communication
 *   with external devices.
 * WIRE is the I2C channel.
 * RADIO is the RF24 channel.
 * MQTT is the MQTT channel.
 * FILE is the file system channel.
 */

#define ONULL 0
#define OSERIAL 1
#define ODSP 2
#define OGRAPH 3
#define OPRT 4
#define OWIRE 7
#define ORADIO 8
#define OMQTT  9
#define OFILE 16

#define INULL 0
#define ISERIAL 1
#define IKEYBOARD 2
#define IGRAPH 3  
#define ISERIAL1 4
#define IWIRE 7
#define IRADIO 8
#define IMQTT  9
#define IFILE 16

/* 
 * Global variables of the runtime env, visible to BASIC. 
 * These are the variables that BASIC provides to the runtime  
 * environment. They are used all over the BASIC code. Some 
 * could be encapsulated as function calls calls.
 *
 * Variables to control the io device channels. 
 *
 * id: the current input device
 * od: the current output device
 * idd: the default input device in interactive mode
 * odd: the default output device in interactive mode
 * ioer: the io error   
 */
extern int8_t id; 
extern int8_t od; 
extern int8_t idd;
extern int8_t odd;
extern int8_t ioer;

/* 
 * Io control flags.
 *
 * These flags are used to control the I/O devices.
 * kbdrepeat: the keyboard repeat flag for the keypad of a shield
 *  only used by SET and defined in the keypad code
 * blockmode: the blockmode flag, switch a channel to blockmode
 * sendcr: the sendcr flag, send a carriage return after a newline if true
 */

extern uint8_t kbdrepeat;
extern uint8_t blockmode;
extern uint8_t sendcr;

/* breaks, signaly back that the breakcondition has been detected */
extern char breakcondition;

/* counts the outputed characters on streams 0-4, used to emulate a real tab */
extern uint8_t charcount[5]; /* devices 0-4 support tabing */

/* the memory buffer comes from BASIC in this version, it is the input buffer for lines */
extern char ibuffer[BUFSIZE];

/* only needed in POSIX worlds */
extern uint8_t breaksignal; 
extern uint8_t vt52active;

/* the string buffer the interpreter needs, here to be known by BASIC */
extern char spistrbuf1[SPIRAMSBSIZE], spistrbuf2[SPIRAMSBSIZE];

/* 
 * the mqtt variable the interpreter needs.
 * The following parameters are configured here:
 * 
 * MQTTLENGTH: the length of the mqtt topic, restricted to 32 by default.
 * MQTTBLENGTH: the length of the mqtt buffer, 128 by default.
 * MQTTNAMELENGTH: the length of the autogenerated mqtt name, 12 by default. 
 * The mqtt name is used to identify the device in the mqtt network.
 * 
 * mqtt_otopic: the outgoing topic
 * mqtt_itopic: the incoming topic
 * mqttname: the name of the device in the mqtt network
*/

#define MQTTLENGTH 32
#define MQTTBLENGTH 128
#define MQTTNAMELENGTH 12

extern char mqtt_otopic[MQTTLENGTH];
extern char mqtt_itopic[MQTTLENGTH];
extern char mqttname[];

/* a byte in the runtime memory containing the system type */
extern uint8_t bsystype;

/* 
 *  Console logger functions for the runtime code. Runtime does not know 
 *  anything about output deviced. BASIC is to provide this. This 
 *  is used for debugging and logging.
 */

 extern void consolelog(char*);
 extern void consolelognum(int);
 
/*
 * Statup function. They start the runtime environment.
 * 
 * The functions timeinit(), wiringbegin(), signalon()
 * are always empty on Arduino, they are only used in 
 * the POSIX branch of the code.
 * 
 * timeinit() initializes the time functions.
 * wiringbegin() initializes the wiring functions, this is needed on 
 *   Raspberry PI.
 * signalon() initializes the signal handling, this is needed on
 *   Unix like systems and Windows. 
 * 
 * BASIC calls these functions once to start the timing, wiring, and 
 * signal handling.
 */

 void timeinit();	
 void wiringbegin();	
 void signalon();

/* 
 * Start the SPI bus. Called once on start. Needed on Arduino. 
 * Empty in the POSIX branch of the code.
 * 
 * Some libraries also try to start the SPI which may lead to on override of 
 * the PIN settings if the library code is not clean - currenty no conflict known.
 * for the libraries used here. Old SD card libraries have problems as they always 
 * start the SPI bus with default settings and cannot get the settings from the
 * SPI.begin() call. In these cases patching of the SD library is needed.
 */

 void spibegin();

/*
 * Memory allocation functions.
 * 
 * BASIC calls freememorysize() to detemine how much memory can be allocated 
 * savely on the heap.
 * BASIC calls restartsystem() for a complete reboot. 
 * freeRam() is the actual free heap. Used by freememorysize() and in USR()
 * 
 * Arduino data from https://docs.arduino.cc/learn/programming/memory-guide
 */

 long freememorysize(); /* determine how much actually to allocate */
 void restartsystem(); /* cold start of the MCU */
 long freeRam();	/* try to find the free heap after alocating all globals */
 
 /* Test function for real time clock interrupt, currently not useable. 
     Kept for the future. */ 
 void rtcsqw();
 void aftersleepinterrupt(void);
 void activatesleep(long);
 
/* 
 * The main IO interface. This is how BASIC uses I/O functions.
 *
 * ioinit(): called at setup to initialize what ever io is needed
 * iostat(): check which io devices are available
 * iodefaults(): called at setup and while changing to interactive mode 
 *       to set the default io devices
 * cheof(): checks for end of file condition on the current input stream
 * inch(): gets one character from the current input stream and waits for it
 * checkch(): checks for one character on the current input stream, non blocking
 * availch(): checks for available characters on the current input stream
 * inb(): reads a block of characters from the current input stream
 * ins(): reads an entire line from the current input stream, usually by consins()
 * outch(): prints one ascii character to the current output stream
 * outs(): prints a string of characters to the current output stream
 */

 void ioinit();
 int iostat(int);
 void iodefaults();
 int cheof(int);
 char inch();
 char checkch();
 uint16_t availch();
 uint16_t inb(char*, int16_t);
 uint16_t ins(char*, uint16_t);
 void outch(char);
 void outs(char*, uint16_t);

/* 
 *  Timeing functions and background tasks. 
 *  
 *  byield() must be called after every statement and in all 
 *  waiting loops for I/O. BASIC gives back the unneeded 
 *  CPU cycles by calling byield().
 *  
 *  byield() allows three levels of background tasks. 
 *
 *  BASICBGTASK controls if time for background tasks is 
 *  needed, usually set by hardware features
 *
 *  YIELDINTERVAL by default is 32, generating a 32 ms call
 *    to the network loop function. This is the frequency 
 *    yieldfunction() is called.
 *
 *  LONGYIELDINTERVAL by default is 1000, generating a one second
 *    call to maintenance functions. This is the frequency 
 *    longyieldfunction() is called.
 *    
 *  fastticker() is called in every byield for fast I/O control.
 *    It is currently only used for the tone emulation.
 *    
 *  byield() calls back bloop() in the BASIC interpreter for user 
 *    defined background tasks in an Arduino style loop() function.
 * 
 *  bdelay() is a delay function using byield() to allow for
 *   background tasks to run even when the main code does a delay.
 *
 *  The yield mechanism is needed for ESP8266 yields, network client 
 *  loops and other timing related functions.
 * 
 *  yieldschedule() is a function that calls the buildin scheduler 
 *   of some platforms. Currently it is only used in ESP8266. The 
 *   core on this boards does not tolerate that the loop() function
 *   does not return and crashes the system. This can be prevented 
 *   by calling yieldschedule() often enough.  
 */

#define LONGYIELDINTERVAL 1000
#define YIELDINTERVAL 32

void byield(); 
void bdelay(uint32_t); 
void fastticker(); 
void yieldfunction(); 
void longyieldfunction();
void yieldschedule();

/* 
 * This function measures the fast ticker frequency in microseconds.
 * This can be accessed with USR(0, 35) in BASIC.
 * Activate this only for test  purposes as it slows down the interpreter. 
 * The value is the shortest timeframe the interpreter can handle. Activated 
 * if the code is compiled with FASTTICKERPROFILE in hardware.h.
 */

void fasttickerprofile();
void clearfasttickerprofile();
int  avgfastticker();

/* 
 * EEPROM handling, these function enable the @E array and 
 * loading and saving to EEPROM with the "!" mechanism
 * 
 * The EEPROM code can address EEPROMS up to 64 kB. It returns 
 * signed byte values which corresponds to the definition of 
 * mem_t in BASIC. This is needed because running from EEPROM
 * requires negative token values to be recongized. 
 * 
 * ebegin() starts the EEPROM code. Needed for the emulations.
 * eflush() writes the EEPROM buffer to the EEPROM. Also this is 
 *    mainly needed in the emulations. 
 * elength() returns the length of the EEPROM.
 * eupdate() updates one EEPROM cell with a value. Does not flush. 
 * eread() reads one EEPROM cell.
 */ 

void ebegin(); 
void eflush();
uint16_t elength();
void eupdate(uint16_t, int8_t);
int8_t eread(uint16_t);

/* 
 *  The wrappers of the arduino io functions.
 *  
 *  The normalize the differences of some of the Arduino cores 
 *  and raspberyy PI wiring implementations.
 * 
 *  Pin numbers are the raw numerical pin values in BASIC. 
 *  The functions are called with this raw pin number and the value.
 * 
 * The functions are:
 * aread(pin): read an analog value from a pin
 * dread(pin): read a digital value from a pin
 * awrite(pin, value): write an analog value to a pin
 * dwrite(pin, value): write a digital value to a pin
 * pinm(pin, mode): set the mode of a pin, mode is also the raw value from the core
 * pulsein(pin, value, timeout): read a pulse from a pin, timeout in microseconds
 * void pulseout(unit, pin, duration, val, repetition, interval): generate a pulse on a pin
 *    unit is the timeunit in microsecind and the duration is the pulse length in this unit.
 *    This is needed for system were the number_t is only 16 bit. This way longer pulses can 
 *    be generated.
 * void playtone(pin, frequency, duration, volume): generate a tone on a pin. 
 *   frequency is the frequency in Hz, duration the duration in ms, volume the volume in percent.
 *   The tone is generated in the background, the function returns immediately.
 * tonetoggle(): toggle the tone generation, needed for the tone emulation, this is called 
 *  by byield() to generate the tone.
 */ 

uint16_t aread(uint8_t);
uint8_t dread(uint8_t);
void awrite(uint8_t, uint16_t);
void dwrite(uint8_t, uint8_t);
void pinm(uint8_t, uint8_t);
uint32_t pulsein(uint8_t, uint8_t, uint32_t);
void pulseout(uint16_t, uint8_t, uint16_t, uint16_t, uint16_t, uint16_t);
void playtone(uint8_t, uint16_t, uint16_t, uint8_t);
void tonetoggle(); /* internal function of the tone emulation, called by byield */

/*
 * The break pin code. This is a pin that can be used to break the execution of the
 * BASIC code. This is used as an alternative to the BREAK key in the terminal.
 * 
 * brakepinbegin() initializes the break pin, usually a button connected to a pin.
 * getbreakpin() returns the state of the break pin. This is called in statement() to 
 * check if the break condition is met and then change the interpreter state at the end
 * of the statement.
 */

void breakpinbegin();
uint8_t getbreakpin();

/* 
 * The hardware port register access functions.
 * They can be used to directly access hardware ports. Typically they 
 * call port macros like PORTB on the Arduino AVR platform. They are very 
 * fast and can be used to implement fast I/O functions but they are hardware
 * dependent and not portable. Currently only AVR UNO and MEGA are implemented.
 * 
 * The calling mechanism in BASIC is the special array @P()for read and write.
 */

void portwrite(uint8_t, int);
int portread(uint8_t);
void ddrwrite(uint8_t, int);
int ddrread(uint8_t);
int pinread(uint8_t);

/*
 * Prototypes for the interrupt interface. This uses the standard Arduino
 * interrupt functions. 
 */

uint8_t pintointerrupt(uint8_t);
void attachinterrupt(uint8_t, void (*f)(), uint8_t);
void detachinterrupt(uint8_t);

/* some have PinStatus and some don't */
#if !(defined(ARDUINO_ARCH_MBED_RP2040) || defined(ARDUINO_ARCH_MBED_NANO) || \
     defined(ARDUINO_ARCH_RENESAS) || defined(ARDUINO_ARCH_MBED_GIGA) || \
     defined(ARDUINO_ARCH_SAMD) || defined(ARDUINO_ARCH_MEGAAVR)) || defined(ARDUINO_SEEED_XIAO_M0)
typedef int PinStatus;
#endif

/*
 * IO channel 0 - the buffer I/O device.
 *
 * This is a stream to write to the input buffer from BASIC. 
 */

 void bufferbegin();
 uint8_t bufferstat(uint8_t);
 void bufferwrite(char);
 char bufferread();
 char buffercheckch();
 uint16_t bufferavailable();
 uint16_t bufferins(char*, uint16_t);
 void bufferouts(char*, uint16_t);
 

/*
  * IO channel 1 - the serial I/O device.
  * 
  * Primary serial code uses the Serial object or Picoserial on 
  * Arduino. On POSIX systems it uses the standard input/output.
  * 
  * Functions are: 
  * 
  * serialbegin(): start the serial port
  * serialread(): read a character from the serial port, this is blocking 
  *  for the standard Serial object and non blocking for Picoserial.
  *  Picoserial is not character oriented. It read one entire line. 
  * serialstat(s): check the status of the serial port
  * serialwrite(c): write a character to the serial port
  * serialcheckch(): check if a character is available without blocking
  * serialavailable(): check if characters are available
  * serialflush(): flush the serial port
  * serialins(s, l): read a line from the serial port
  */
 
 void serialbegin();
 char serialread();
 uint8_t serialstat(uint8_t); /* state information on the serial port */
 void serialwrite(char); /* write to a serial stream */
 char serialcheckch(); /* check on a character, needed for breaking */
 uint16_t serialavailable(); /* avail method, needed for AVAIL() */ 
 void serialflush(); /* flush serial */
 uint16_t serialins(char*, uint16_t); /* read a line from serial */
 
 /*
  * reading from the console with inch or the picoserial callback.
  * consins() is used for all devices that have a character oriented
  * input and creates entire lines from it.
  */

 uint16_t consins(char *, uint16_t);

/* 
 * On Arduino Serial is a big object that needs a lot of memory 
 * on the smaller boards. Picoserial is smaller. It is mainly 
 * for the small 8bit AVR boards. It uses the UART macros directly.
 * 
 * The picoseria has an own interrupt function. This is used to fill 
 * the input buffer directly on read. Write is standard like in 
 * the serial code. Currently picoserial is only implemented for
 * AVR UNO, NANO and MEGA. 
 *  
 * As echoing is done in the interrupt routine, the code cannot be 
 * used to receive keystrokes from serial and then display the echo
 * directly to a display. To do this the write command in picogetchar
 * would have to be replaced with a outch() that then redirects to the 
 * display driver. This would be very tricky from the timing point of 
 * view if the display driver code is slow. 
 * 
 * The code for the UART control is mostly taken from PicoSerial
 * https://github.com/gitcnd/PicoSerial, originally written by Chris Drake
 * and published under GPL3.0 just like this code.
 * 
 * Functions for the picoserial code are:
 * 
 * picobegin(baud): start the picoserial port with the baud rate baud
 * picowrite(c): write a character to the picoserial port
 * picoins(s, l): read a line from the picoserial port
 * 
 */

 void picobegin(uint32_t);
 void picowrite(char);
 uint16_t picoins(char *, uint16_t);
 
 /* 
  *  picogetchar: this is the interrupt service routine.  It 
  *  recieves a character and feeds it into a buffer and echos it
  *  back. The logic here is that the ins() code sets the buffer 
  *  to the input buffer. Only then the routine starts writing to the 
  *  buffer. Once a newline is received, the length information is set 
  *  and picoa is also set to 1 indicating an available string, this stops
  *  recevieing bytes until the input is processed by the calling code.
  */
 void picogetchar(char);

/*
 * IO channel 2 - the display I/O device. 
 *
 * DISPLAY driver code section. The display driver is a generic text and graphics
 * output device. Characters are buffered in a display buffer if DISPLAYCANSCROLL 
 * is defined. These displays can scroll. Scrolling is handled by the display driver.
 * It is soft scroll, meaning that the display buffer is scrolled and the display is
 * updated. This is slow for large displays. Hardware scrolling is not yet implemented.
 * 
 * The display driver is used by the terminal code to output text and
 * graphics. It is needed because there is no standard terminal emulation on Arduino
 * systems. It tries to be so generic that everything from small 16*2 LCDs to large
 * TFT displays can be used. It contains a VT52 state engine to process control
 * sequences.
 * 
 * The hardware dependent part of the display driver has to implement the following
 * functions:
 *
 * Text display functions:
 * 
 * dsp_rows, dsp_columns: size of the display
 * dspbegin(): start the display - can be empty
 * dspprintchar(c, col, row): print a character at a given position
 *      logic here that col is the x coordinate and row the y coordinate
 *      for text and graphics the display coordinate system has its origin
 *      in the upper left corner
 * dspclear(): clear the display
 * dspupdate(): update the display, this function is needed for displays that
 *      have a buffer and can update the display after a series of prints. 
 *      Examples are epaper displays and LCD displays like the Nokia. Writing 
 *      directly to them is slow. 
 * dspsetcursor(c): switch the cursor on or off, typically used for text 
 *      displays with blinking cursors.
 * dspsetfgcolor(c): set the foreground color of the display.
 * dspsetbgcolor(c): set the background color of the display.
 *      c is a VGA color. 4bit VGA colors are used for text displays. 
 *      Graphics is 24 bit color rgb and 8 bit VGA color.
 * dspsetreverse(c): set the reverse mode of the display, currently unused.
 * dspident(): return the display type, currently unused.
 * 
 * For displays with color, the macro DISPLAYHASCOLOR has to be defined.
 * The text display buffer then contains one byte for the character and 
 * one byte for color and font. 
 *
 * All displays which have these functions can be used with the 
 * generic display driver below. For minimal functionality only
 * dspprintchar() and dspclear() are needed. The screen dimensions
 * have to be set in dsp_rows and dsp_columns.
 * 
 * Graphics displays need to implement the functions 
 * 
 * rgbcolor(r, g, b): set the color for graphics. The color
 *     is 24 bit rgb. This function needs to convert the byte 
 *     values to the native color of the display.
 * vgacolor(c): set the color for text. The color is a 256 VGA  
 *    color for most displays. This function needs to convert this
 *    one byte value to the native color of the display.
 * These two functions are called by the BASIC COLOR command.
 * 
 * plot(x, y): plot a pixel at x, y
 * line(x1, y1, x2, y2): draw a line from x1, y1 to x2, y2
 * rect(x1, y1, x2, y2): draw a rectangle from x1, y1 to x2, y2
 * frect(x1, y1, x2, y2): draw a filled rectangle from x1, y1 to x2, y2
 * circle(x, y, r): draw a circle with center x, y and radius r
 * fcircle(x, y, r): draw a filled circle with center x, y and radius r
 * 
 * 
 * Color is currently either 24 bit or 8 bit 16 VGA color. BW and displays
 * only have 0 and 1 as colors. Text is buffered in 4 bit VGA color (see below).
 */

 /* Generate a 4 bit vga color from a given rgb color, to be checked */
uint8_t rgbtovga(uint8_t, uint8_t, uint8_t);


/* Text functions */
void dspbegin(); 
void dspprintchar(char, uint8_t, uint8_t);
void dspclear();
void dspupdate();
void dspsetcursor(uint8_t);
void dspsavepen();
void dsprestorepen();
void dspsetfgcolor(uint8_t);
void dspsetbgcolor(uint8_t);
void dspsetreverse(uint8_t);
uint8_t dspident();

/* Graphics functions */
void rgbcolor(uint8_t, uint8_t, uint8_t);
void vgacolor(uint8_t);
void plot(int, int);
void line(int, int, int, int);
void rect(int, int, int, int);
void frect(int, int, int, int);
void circle(int, int, int);
void fcircle(int, int, int);

/* to whom the bell tolls - implement this to you own liking, reacts to ASCII 7 */
void dspbell(); 

/*
 * The public functions of the display driver are the following:
 *
 * dspouts(s, l): print a string of length l to the display. This 
 *      function is only used for output on certain graphics displays
 *      These displays expect an entire string to be printed at once.
 *      Currently this is only implemented for epaper displays.
 * dspwrite(c): print a character to the display. This function is 
 *      the main output method for text displays. It prints a character
 *      at the current cursor position and updates the cursor position.
 *      For vt52 capable displays, the character goes through the vt52
 *      state engine and it processed there. 
 * dspstat(s): check the status of the display. It returns 1 if the 
 *      display is present and 0 if it is not. 
 * dspactive(): check if the display is the current output device.
 *      This function is used to control scrolling in the LIST command.
 * dspwaitonscroll(): this function waits for character input if the 
 *      display wants to scroll.  This is used in the LIST command to
 *       wait for a keypress before scrolling the display. It returns the 
 *      character that was pressed. This can also be used to end the output
 *      of the LIST command.
 * dspsetupdatemode(m): set the update mode of the display. Valid update
 *     modes are 0, 1, 2. 0 is character mode, 1 is line mode, 2 is page mode.
 *     In character mode, the display is updated after every character. In line
 *     mode, the display is updated after every line. In page mode, the display
 *     is updated after an ETX character. This function is only used for displays
 *     that implement the dspupdate() function.
 * dspgetupdatemode(): get the current update mode of the display.
 * dspgraphupdate(): update the display after a series of graphics commands. While
 *     dspsetupdatemode() and dspgetupdatemode() control the update from the text buffer,
 *     dspgraphupdate() controls the update from the graphics buffer. See for example 
 *     the Nokia display as an example. This function must be called after graphics 
 *     operations to update the display. Typically this is done in the graphics functions
 *     like line(), rect(), circle(), etc.
 * dspsetcursorx(x): set the x coordinate of the cursor
 * dspsetcursory(y): set the y coordinate of the cursor
 * dspgetcursorx(): get the x coordinate of the cursor
 * dspgetcursory(): get the y coordinate of the cursor
 */

void dspouts(char*, uint16_t);
void dspwrite(char);
uint8_t dspstat(uint8_t);
uint8_t dspactive();
char dspwaitonscroll();
void dspsetupdatemode(uint8_t);
uint8_t dspgetupdatemode(); 
void dspgraphupdate();
void dspsetcursorx(uint8_t);
void dspsetcursory(uint8_t);
uint8_t dspgetcursorx();
uint8_t dspgetcursory();

/* 
 * These are the buffer control functions for the display driver.
 * 
 * Color handling: 
 * 
 * Non scrolling displays simply use the pen color of the display
 * stored in dspfgcolor() to paint the information on the screen.
 * 
 * For scrolling displays we store the color information of every
 * character in the display buffer to enable scrolling with color. 
 * To limit the storage requirements, this code translates the color 
 * to a 4 bit VGA color. This means that if BASIC uses 24 bit colors, 
 * the color may change at scroll
 *
 * For color displays the buffer is a 16 bit object. The lower 8 bits 
 * plus the sign are the character, higher 7 the color and font.
 * For monochrome just the character is stored in an 8 bit object.
 * 
 * The type dspbuffer_t is defined according to the display type.
 * 
 * The following functions are used to control the display buffer:
 * 
 * dspget(): get a character from the display buffer in form of a linear
 *    address. This is only used for the special array @D() in BASIC.
 *    It allows direct access to the display buffer.
 * dspgetrc(r, c): get a character from the display buffer at row r and column c.
 *    This is used for the print function of the vt52 terminal. An entire display 
 *    can be sent to the printer device OPRT
 * dspgetc(c): get a character from the current line at column c. Also this is 
 *   used for the print function of the VT52 terminal. This only sents the 
 *   current line to the printer device OPRT.
 * For both functions the actual print code is in the VT52 object.
 * These three functions are somewhat redundant.
 * 
 * dspsetxy(c, x, y): set a character at x, y in the display buffer and on the 
 *   display. This function is needed for various control sequences of the VT52 
 *   terminal.
 * dspset(c, v): set a character at a linear address in the display buffer. Also u
 *   used for the @D() array in BASIC.
 * 
 * dspsetscrollmode(m, l): set the scroll mode. m is the mode and l is the number
 *    of lines to be scrolled. Mode 0 means that dspwaitonscroll() does not 
 *    wait for keyboard input. Mode 1 is wait for input. 
 * dspbufferclear(): clears the input buffer. 
 * dspscroll(l, t): do the actual scrolling. l is the number of lines to be scrolled.
 *    t is the topmost line included in the scroll. O by default.
 * dspreversescroll(l): reverse scroll from line l downward.
 */

#ifdef DISPLAYHASCOLOR
typedef short dspbuffer_t;
#else
typedef char dspbuffer_t;
#endif

dspbuffer_t dspget(uint16_t);
dspbuffer_t dspgetrc(uint8_t, uint8_t);
dspbuffer_t dspgetc(uint8_t);

void dspsetxy(dspbuffer_t, uint8_t, uint8_t); 
void dspset(uint16_t, dspbuffer_t);
void dspsetscrollmode(uint8_t, uint8_t);

void dspbufferclear(); 
void dspscroll(uint8_t, uint8_t); 
void dspreversescroll(uint8_t); 

/*
 * A VT52 state engine is implemented and works for buffered and 
 * unbuffered displays. Only buffered displays have the full VT52
 * feature set including most of the GEMDOS extensions described here:
 * https://en.wikipedia.org/wiki/VT52
 * 
 * The VT52 state engine processes sequences of the form <ESC> char.
 * 
 * In addition to this, it also gives back certain return values. 
 * The can be read by vt52read() and vt52avail().
 * vt52push() is used to push characters into the VT52 buffer.
 * vt52number() is used to convert a character into the VT52 number format.
 * vt52graphcommand() is a VT52 extension to display graphics on the screen.
 */

char vt52read(); 
uint8_t vt52avail(); 
void vt52push(char); 
uint8_t vt52number(char); 
void vt52graphcommand(uint8_t);

/* 
 * this is a special part of the vt52 code with this, the terminal 
 * can control the digital and analog pins.
 * 
 * It is meant for situations where the terminal is controlled by a (powerful)
 * device with no or very few I/O pins. It can use the pins of the Arduino through  
 * the terminal. 
 * 
 * This works as long as everything stays within the terminals timescale.
 * On a 9600 baud interface, the character processing time is 1ms, everything 
 * slower than approximately 10ms can be done through the serial line.
 */

void vt52wiringcommand(uint8_t);

/* the vt52 state engine */
void dspvt52(char*);

/* 
 * Code for the VGA system of Fabgl. This is a full VT52 terminal. The 
 * display driver is not used for this. 
 */

void vgabegin(); 
int vgastat(uint8_t); 
void vgascale(int*, int*); 
void vgawrite(char); 
void vgaend();

/* 
 * IO channel 2 (input) - the keyboard I/O device.
 *
 * Keyboard code for either the Fablib Terminal class,  
 * PS2Keyboard or other keyboards. 
 * 
 * PS2Keyboard: please note that you need the patched 
 * version here as mentioned above.
 * 
 * Keyboards implement kbdbegin() which is called at startup
 * and kbdstat() which is called to check if the keyboard is
 * available.
 * 
 * Keyboards need to provide the following functions:
 * 
 * kbdavailable(): check if a character is available
 * kbdread(): read a character from the keyboard
 * kbdcheckch(): check if a character is available without blocking
 * kbdins(): read a line from the keyboard
 * 
 * kbdcheckch() is for interrupting running BASIC code with a 
 * BREAKCHAR character from the keyboard. If this functions is 
 * not implemented, the BREAKCHAR character is ignored.
 * 
 * kbdins() is usually using consins() to read a line from the
 * keyboard repeatedly calling kbdread() until a newline is
 * received. A keyboard can also bring its on kbdins() function.
 */

void kbdbegin();
uint8_t kbdstat(uint8_t);
uint8_t kbdavailable();
char kbdread();
char kbdcheckch();
uint16_t kbdins(char*, uint16_t);

/* IO channel 3 - reserved for future use */

 /*
  * IO channel 4 - the second serial I/O device.
  * 
  * This is the (mostly) the Serial1 object 
  * on Arduino. On POSIX systems this opens a serial port like /dev/ttyUSB1.
  * This &4 in BASIC.
  * 
  * Functions are:
  * 
  * prtbegin(): start the serial port
  * prtopen(name, baud): open the serial port with the baud rate baud. Only 
  *  neded in POSIX to open the port.
  * prtclose(): close the serial port
  * prtstat(s): check the status of the serial port
  * prtwrite(c): write a character to the serial port
  * prtread(): read a character from the serial port
  * prtcheckch(): check if a character is available without blocking
  * prtavailable(): check if characters are available
  * prtset(baud): set the baud rate of the serial port
  * prtins(s, l): read a line from the serial port
  */
 
  void prtbegin();
  char prtopen(char*, uint16_t); 
  void prtclose();
  uint8_t prtstat(uint8_t);
  void prtwrite(char);
  char prtread();
  char prtcheckch();
  uint16_t prtavailable();
  void prtset(uint32_t);
  uint16_t prtins(char*, uint16_t);

/* 
 * IO channel 7 - I2C through the Wire library.
 *
 * The wire code, direct access to wire communication.
 *
 * In master mode wire_slaveid is the I2C address bound 
 * to channel &7 and wire_myid is 0.
 * 
 * In slave mode wire_myid is the devices slave address
 * and wire_slaveid is 0.
 * 
 * The maximum number of bytes the Wire library can handle
 * is 32. This is given by the Wire library.
 * 
 * Wire is handled through the following functions:
 * 
 * wirebegin(): start the wire system. 
 * wireslavebegin(id): start the wire system as a slave with the id.
 * wirestat(s): check if the wire system is available.
 * wireavailable(): check if characters are available in slave mode.
 * wireonreceive(h): set the event handler for received data on a slave.
 * wireonrequest(): set the event handler for request on a slave.
 * wireopen(id, slaveid): open the wire system as a master with id to 
 *   the slave id.
 * wireread(): read a character from the wire system.
 * wirewrite(c): write a character to the wire system.
 * wireins(l, s): read a line l from the wire system max length is s.
 * wireouts(l, s): write a line l to the wire system max length is s.
 * wirereadbyte(s): read from single byte from the wire slave s.
 * wirewritebyte(s, b): write a single byte b to the wire slave s.
 * wirewriteword(s, b1, b2): write two bytes b1 and b2 to the wire slave s.
 * (the latter three functions cover most of the wire communication to simple
 * devices like sensors and displays). They are available in BASIC as the WIRE
 * command. 
 */ 

 void wirebegin();
 void wireslavebegin(uint8_t);
 uint8_t wirestat(uint8_t);
 uint16_t wireavailable(); 
 void wireonreceive(int);
 void wireonrequest(); 
 void wireopen(uint8_t, uint8_t);
 char wireread(); 
 void wirewrite(char c);
 uint16_t wireins(char*, uint8_t);
 void wireouts(char*, uint8_t);

 /* 
 int16_t wirereadbyte(uint8_t);
 void wirewritebyte(uint8_t, uint8_t);
 void wirewriteword(uint8_t, uint8_t, uint8_t);
*/
/* new byte wire interface for direct access */
void wirestart(uint8_t);
void wirewritebyte(uint8_t);
uint8_t wirestop();
int16_t wirereadbyte(uint8_t);

/* 
 * IO channel 8 - the RF24 radio I/O device.
 *
 * Read from the radio interface, radio is always block 
 * oriented. This function is called from ins for an entire 
 * line.
 * 
 * In blockmode the entire message is returned in the 
 * receiving string while in line mode the length of the 
 * string is adapted. Blockmode can be used to transfer
 * binary data.
 * 
 * The radio code is rather obsolet and not used a lot.
 * 
 * On RF24 we always read from pipe 1 and use pipe 0 for writing, 
 * the filename is the pipe address, by default the radio 
 * goes to reading mode after open and is only stopped for 
 * write.
 */

 uint8_t radiostat(uint8_t); 
 uint64_t pipeaddr(const char*); 
 uint16_t radioins(char*, uint8_t); 
 void radioouts(char *, uint8_t); 
 uint16_t radioavailable(); 
 char radioread();
 void iradioopen(const char *);
 void oradioopen(const char *);
 void radioset(uint8_t);

/*
 * IO channel 9 - the network I/O device.
 *
 * Only MQTT is implemented at the moment. Other protocols
 * will be channel 10-15. 
 *
 * Underlying networks can be the Wifi classes of the ESP, MKR, and
 * STM32 cores. The network code is based on the PubSubClient library.
 * Ethernet is supported with the standard Ethernet library on Arduino.
 * 
 * On POSIX systems networking is currently not supported.
 *
 * No encryptionis implemented in MQTT. Only unencrypted servers can be used.
 * 
 * Buffers are defined above in the mqtt section.
 * 
 * MQTTLENGTH: the length of the mqtt topic, restricted to 32 by default.
 * MQTTBLENGTH: the length of the mqtt buffer, 128 by default.
 * MQTTNAMELENGTH: the length of the autogenerated mqtt name, 12 by default.
 *
 * wifisettings.h is the generic network definition file all network settings 
 * are compiled into the code. BASIC cannot change them at runtime.
 * 
 * Low level network functions are:
 * 
 * netbegin(): start the network
 * netstop(): stop the network
 * netreconnect(): reconnect the network
 * netconnected(): check if the network is connected
 * 
 * BASIC uses these function to control the network and reconnect if
 * the connection is lost.
 */

 void netbegin();
 void netstop();
 void netreconnect();
 uint8_t netconnected();
 
 /*
  * The mqtt prototypes used by BASIC are:
  * 
  * mqttbegin(): start the mqtt client
  * mqttsetname(): set the name of the mqtt client. The name is autogenerated.
  * mqttstat(s): check the status of the mqtt client
  * mqttreconnect(): reconnect the mqtt client
  * mqttstate(): get the state of the mqtt client (redunant to mqttstat())
  * mqttsubscribe(t): subscribe to a topic
  * mqttunsubscribe(): unsubscribe from a topic
  * mqttsettopic(t): set the topic of the mqtt client
  * mqttouts(s, l): send a string of length l to the mqtt server
  * mqttwrite(c): send a character to the mqtt server.
  * These two functions work buffered. The write to the MQTT output buffer. Only
  * when the buffer is full or a newline is received, the buffer is sent to the
  * server.
  * mqttread(): read a character from the mqtt input buffer.
  * mqttins(s, l): read a line from the mqtt input buffer.
  * mqttavailable(): check if characters are available in the mqtt input buffer. 
  * mqttcheckch(): get the next character from the mqtt input buffer without advancing.
  */

 void mqttbegin();
 void mqttsetname();
 uint8_t mqttstat(uint8_t);
 uint8_t mqttreconnect();
 uint8_t mqttstate();
 void mqttsubscribe(const char*);
 void mqttunsubscribe();
 void mqttsettopic(const char*);
 void mqttouts(const char*, uint16_t);
 void mqttwrite(const char);
 char mqttread();
 uint16_t mqttins(char*, uint16_t);
 uint16_t mqttavailable();
 char mqttcheckch();
 
 /*
  * The callback function of the pubsub client. This is called when a
  * message is received from the mqtt server. 
  * 
  * The Arduino type byte is used here because it is used this way in Pubsub.
  */
 void mqttcallback(char*, byte*, unsigned int);
 
/* 
 * IO channel 16 - the file system I/O device.
 *
 * The file system driver - all methods needed to support BASIC fs access. 
 * 
 * Different filesystems need different prefixes and fs objects, these 
 * filesystems use the stream API in the Arduino world.
 * 
 *  The functions to access the filesystem are:
 * 
 * fsbegin(): start the filesystem
 * fsstat(s): check the status of the filesystem
 * mkfilename(s): make a filename from a string
 * rmrootfsprefix(s): remove the prefix from a filename
 * 
 * Different filesystems have different prefixes. In BASIC we 
 * only show a flat file system with no path names and prefixes.
 * 
 * Supported filesystems are:
 * 
 * SPIFF - the internal flash file system of the ESP32 and ESP8266
 * SD - the SD card file system (no formatting)
 * EFS - the file system EFS for I2C EEPROMs
 * LittleFS - the LittleFS file system on RP2040
 * USB devices on Arduino GIGA boards
 * Posix and Windows file systems on POSIX systems
 */

 void fsbegin(); 
 uint8_t fsstat(uint8_t);
 char* mkfilename(const char*);
 const char* rmrootfsprefix(const char*); 
 
 /*
  *	File I/O function on an Arduino:
  * 
  *  filewrite(c): write a character to a file
  *  fileread(): read a character from a file
  *  fileavailable(): check if a character is available in the file
  *  ifileopen(s): open a file for input
  *  ifileclose(): close a file for input
  *  ofileopen(s, m): open a file for output with mode m
  *  ofileclose(): close a file for output 
  * 
  * The wrapper and BASIC currently only support one file for read 
  * and one file for write.
  */
 
 void filewrite(char);
 char fileread();
 int fileavailable(); /* is int because some of the fs do this */
 uint8_t ifileopen(const char*);
 void ifileclose();
 uint8_t ofileopen(const char*, const char*);
 void ofileclose();
 
 /*
  * Directory handling for the catalog function these methods are
  * needed for a walkthtrough of one directory. 
  * 
  * The logic is:
  *
  * rootopen()
  * while rootnextfile()
  * 	if rootisfile() print rootfilename() rootfilesize()
  *	rootfileclose()
  * rootclose()
  * 
  * rootopen(): opens the root directory
  * rootnextfile(): gets the next file in the directory
  * rootisfile(): checks if the file is a file or something else
  * rootfilename(): gets the name of the file
  * rootfilesize(): gets the size of the file
  * rootfileclose(): closes the root file
  */

 void rootopen();
 uint8_t rootnextfile(); 
 uint8_t rootisfile();
 const char* rootfilename();
 uint32_t rootfilesize();
 void rootfileclose(); 
 void rootclose();
 
 /* delete a file, needed in the DELETE command of BASIC */
 void removefile(const char*);
 
 /*
  * Formatting for fdisk of the internal filesystems. This 
  * is not implemented for all filesystems.
  */
 void formatdisk(uint8_t);

/* 
 * The Real Time clock. The interface here offers the values as number_t 
 * combining all values. 
 * 
 * On Arduino, he code does not use an RTC library any more all the 
 * RTC support is builtin now for standard I2C clocks. 
 * 
 * A clock must activate the macro #define HASCLOCK to make the clock 
 * available in BASIC.
 * 
 * Four software models are supported in runtime.cpp for Arduino:
 *  - Built-in clocks of STM32, MKR, and ESP32 are supported by default.
 *  - I2C clocks can be activated: DS1307, DS3231, and DS3232 
 *  - A Real Time Clock emulation using millis()
 * 
 * On POSIX the standard time functions are used and mapped to this API.
 * 
 * rtcget(r) accesses the internal registers of the clock. 
 * r==0 is the seconds, r==1 the minutes, r==2 the hours, r==3 the 
 * day of week, r==4 the day, r==5 the month, r==6 the year.
 * The day of the week feature is not supported by all clocks.
 * rtcset(r, v) sets the internal registers of the clock.
 * 
 * On I2C clocks with NVRAM the  registers 7-255 are accessed as 
 * memory cells through these functions.
 * 
 * rtcbegin() is called at startup to initialize the clock, normally 
 * a dummy function.
 *
 * rtctimetoutime() converts the clock time to a unix time number.
 * rtcutimetotime() converts the unix time number to a clock time.
 * Both are private functions of the clock emulation.
 * 
 * Code in these two functions is taken from the German Wikipedia
 * article on Unix time. https://de.wikipedia.org/wiki/Unixzeit
 */

void rtcbegin();
uint16_t rtcget(uint8_t); 
void rtcset(uint8_t, uint16_t);
void rtctimetoutime();
void rtcutimetotime();

/* 
 *	Arduino Sensor library code 
 *		The sensorread() is a generic function called by 
 *		SENSOR basic function and command. The first argument
 *		is the sensor and the second argument the value.
 *		sensorread(n, 0) checks if the sensorstatus.
 */
void sensorbegin();
float sensorread(uint8_t, uint8_t);

/*
 * Experimental code to drive SPI SRAM 
 *
 * Currently only the 23LCV512 is implemented, assuming a 64kB SRAM.
 * Part of code is taken in part from the SRAMsimple library.
 * 
 * Two buffers are implemented: 
 * 
 * - a ro buffer used by memread, this buffer is mainly reading the token 
 *  stream at runtime. 
 * - a rw buffer used by memread2 and memwrite2, this buffer is mainly accessing
 *  the heap at runtime. In interactive mode this is also the interface to read 
 *  and write program code to memory. 
 * 
 */

/* the RAM begin method sets the RAM to sequential mode */
uint16_t spirambegin();
int8_t spiramrawread(uint16_t);
void spiram_bufferread(uint16_t, int8_t*, uint16_t);
void spiram_bufferwrite(uint16_t, int8_t*, uint16_t);
int8_t spiram_robufferread(uint16_t);
void spiram_rwbufferflush(); /* flush the buffer */
int8_t spiram_rwbufferread(uint16_t);
void spiram_rwbufferwrite(uint16_t, int8_t); /* the buffered file write */
void spiramrawwrite(uint16_t, int8_t); /* the simple unbuffered byte write, with a cast to signed char */

// defined RUNTIMEH
#endif
